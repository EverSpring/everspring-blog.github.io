---
title: MySQL数据库使用规范
date: 2022-01-17 13:25:00
author: EverSpring
top: false
toc: false
mathjax: false
categories: 数据库
tags:
  - MySQL
  - 规范
---
根据原公司规范、阿里巴巴JAVA规范、58到家MySQL军规合成
### MySQL数据库使用规范
#### 一、建表规约
1. 【强制】数据库名、表名、字段名统一使用小写，多单词统一使用下划线分割
    说明：表名大小写是否敏感可修改数据库参数lower_case_table_names控制，但建议数据库建好后此类参数不可变更
2. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）
3. 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字
4. 【强制】主键索引名为` pk_字段名`；唯一索引名为 `uk_字段名`；普通索引名则为` idx_字段名`
5. 【强制】小数类型为 decimal，禁止使用 float 和 double
    说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储
6. 【强制】如果存储的字符串长度能够确定完全相等，使用 char 定长字符串类型
7. 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率
8. 【可选】表必备三字段：id, create_time, update_time
    说明：其中 id 必为主键，单表时自增、步长为 1。create_time, update_time的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新
9. 【可选】尽量避免使用timestamp，timestamp数据最大值北京时间2038-01-19 11:14:07
10. 【强制】一张表中只能有一个字段定义为ON UPDATE CURRENT_TIMESTAMP
    说明：MySQL 5.6之前一张表只能有一列自动更新时间列；5.7以后支持多列，但如果定义了多列，只有最前面的那一列才会自动更新时间
11. 【可选】表中业务字段尽量不要用timestamp，可用datetime代替，原因见第9点
12. 【推荐】表的命名最好是遵循`业务名称_表的作用`
13. 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表
14. 【推荐】建库、建表字符编码尽量使用utf8mb4
15. 【强制】临时表必须以`tmp_`开头、以日期结尾，备份表必须以`bak_`开头、以日期结尾
16. 【强制】避免使用ENUM类型
    说明：修改ENUM值需要使用ALTER语句；ENUM类型的ORDER BY操作效率低，需要额外操作

#### 二、索引规约
1. 【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引
说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生
2. 【强制】页面搜索严禁左模糊或者全模糊
3. 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。
正例：where a=? and b=? order by c; 索引：a_b_c
反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b 无法排序
4. 【推荐】利用延迟关联或者子查询优化超多分页场景
说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL改写
正例：先快速定位需要获取的 id 段，然后再关联：
```
SELECT t1.* FROM 表 1 as t1, (select id from 表 1 where 条件 LIMIT 100000,20 ) as t2 where t1.id=t2.id
```
5. 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好
说明：
1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
2） ref 指的是使用普通的索引（normal index）。
3） range 对索引进行范围检索。
反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比range还低，与全表扫描是小巫见大巫
6. 【推荐】建组合索引的时候，区分度最高的在最左边
正例：如果 where a=? and b=?，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可
说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c>? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx_d_c
7. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效

#### 三、SQL语句
1. 【推荐】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关
说明：`count(*)`会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行
2. 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0
3. 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题
正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table
4. 【强制】使用 ISNULL()来判断是否为 NULL 值
说明：NULL 与任何值的直接比较都为 NULL
5. 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性
6. 【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内
7. 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句
8. 【强制】delete、update等SQL语句中必须包含where条件，减小数据影响范围
9. 【推荐】尽量避免使用子查询，可以把子查询优化为join操作
	说明：
	* 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响
	* 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大
	* 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询
10. 【推荐】WHERE从句中尽量不要对列进行函数转换和计算，可以通过程序中转换后通过参数传入
正例：where create_time >= '20220101' and create_time < '20220102'
反例：where date(create_time)='20220101'
11. 【推荐】在明显不会有重复值时使用UNION ALL而不是UNION
	说明：
	* UNION会把两个结果集的所有数据放到临时表中后再进行去重操作
	* UNION ALL不会再对结果集进行去重操作
12. 【推荐】拆分复杂的大SQL为多个小SQL
	说明：
	* 大SQL在逻辑上比较复杂，需要占用大量CPU进行计算的SQL
	* SQL拆分后可以通过并行执行来提高处理效率
13. 【强制】超100万行的批量写（UPDATE、DELETE、INSERT）操作，必须要分批多次进行操作
	说明：
	* binlog日志为row格式时会产生大量的日志
	* 容易产生大事务操作
	* binlog日志为row格式时会产生大量的日志
14. 【推荐】数据量超过50万时，尽可能使用NOT EXIST替代NOT IN

#### 四、ORM映射
1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明
	说明：
	* 增加查询分析器解析成本。
	* 增减字段容易与 resultMap 配置不一致
	* 无用字段增加网络消耗，尤其是 text 类型的字段
2. 【推荐】sql.xml 配置参数尽量使用#{}，尽量不要使用${}， 此种方式容易出现 SQL 注入，如果要使用也需要做拼接校验

#### 五、其他
1. 【推荐】写好的SQL，习惯性地explain查看执行计划
2. 【推荐】不建议使用外键约束（foreign key）
3. 【推荐】建议使用预编译语句进行数据库操作
4. 【推荐】程序连接不同的数据库使用不同的账号
说明：为数据库迁移和分库分表留出余地；降低业务耦合度；避免权限过大而产生的安全风险